## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2401`

#### Выполнила: `Гусева Дарья Борисовна`

#### Вариант: `9`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Выбор структуры данных](#2-выбор-структуры-данных)
- [Программа](#3-программа)
### 1. Постановка задачи

> Случайные величины и все, что с ними связано
Краткое описание
Разработать программу для работы со случайными величинами, представленными числами и их вероятностями. Реализовать функции вычисления статистических показателей, преобразования данных и анализа распределений.
Описание функционала
1. Создание случайной величины
Создание объекта с заданным количеством n, где пользователь вводит пары «числовероятность». Проверяются следующие условия:
• Все вероятности неотрицательны;
• Сумма вероятностей равна 1 (с учётом погрешности);
• Каждая вероятность не превышает 1. При нарушении условий ввод корректируется: отрицательные вероятности становятся равными 0, а все вероятности
умножаются на коэффициент для приведения их суммы к 1.
2. Вывод случайной величины
Отображение списка чисел и их вероятностей в столбик в формате: «число - вероятность».
3. Сортировка случайной величины
Ранжирование случайной величины: сортировка чисел по возрастанию значений.
4. Математическое ожидание
Вычисление математического ожидания случайной величины.
5. Дисперсия
Вычисление дисперсии случайной величины.
6. Среднее квадратичное отклонение
Вычисление среднего квадратичного отклонения как квадратного корня из дисперсии.
7. Арифметические операции над числами случайной величины
Преобразование чисел случайной величины: возведение в квадрат, умножение на
константу, добавление значения. Вероятности остаются неизменными.
8. Нахождение медианы
Определение медианы случайной величины: - Если количество чисел нечётное,
медиана — это центральное число; - Если количество чисел чётное, медиана равна
среднему арифметическому двух центральных чисел.
9. Наиболее вероятное число
Определение числа с наибольшей вероятностью.
10. Проверка нормальности распределения
Проверка, является ли распределение нормальным (медиана равна наиболее вероятному значению).
11. Генерация вероятностей из массива
Вычисление вероятностей чисел на основе их частот в заданном массиве.


### 2. Выбор структуры данных

Программа получает 1 натуральное число(количество случайных переменных) и пары число-вероятность. Поэтому для их хранения
можно выделить 1 переменную(n) типа `int` и создать массив чисел(a) типа double для хранения самих чисел и массив чисел
с плавающей точкой(b) типа double для хранения вероятностей.


### 3. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        class RandomValue { //создаем класс для операций со случайными величинами
            private int n = in.nextInt(); //пользователь вводит количество величин
            private double []a = new double[n]; //создаем массив длинной n для хранения величин
            private double []b = new double[n]; //создаем массив для хранения вероятностей
            public void CreateValue() {  //алгоритм для создания списка
                double s = 0; //считаем общее число вероятностей и следим чтобы оно не превышало 1
                int k = 0; //создаем счетчик вероятностей равных нулю чтобы позже уравнять все вероятности
                for(int i = 0; i<n; i++){ //заполняем массивы парами число - вероятность
                    a[i] = in.nextDouble();
                    b[i] = in.nextDouble();
                    s += b[i];
                    if ((b[i]==0)||(s>1)||(b[i]>1)){ //если на этапе заполнения допущена ошибка
                       b[i] = 0; //вероятность приравнивается к нулю
                       k += 1;
                    }
                }
                if (s<1) {
                    for(int i = 0; i<n; i++) {  //исправляем общее число вероятностей: если она меньше единицы, то мы делим
                        if (b[i]!=0) {  //оставшееся количество вероятностей недостающих до 1 на количество ненулевых вероятностей
                            b[i] += (1 - s)/(n - k);  //и распределяем его между всеми ненулевыми вероятностями
                        }
                    }
                }
            }
            public void ReturnValue() {
                for(int i = 0; i<n; i++) {
                    out.println(a[i]+" "+"-"+" "+b[i]);  //выводим в столбик получившиеся случайные величины
                }
            }
            public void Sort() {  //сортируем случайные величины по возрастанию чисел методом пузырька
                double x = 0;
                double y = 0;
                for(int i = 0; i<n-1; i++) {
                    if(a[i]>a[i+1]) {
                        a[i] = x;
                        a[i] = a[i+1];
                        a[i+1] = x;
                        b[i] = y;
                        b[i] = b[i+1];
                        b[i+1] = y;  //меняем местами и числа в массиве a, и их вероятности в массиве b
                    }
                }
            }
            public double MathExp() {  //считаем мат ожидание суммируя произведения случайных величин на их вероятности
                double m = 0;
                for(int i = 0; i<n; i++) {
                    m += a[i] * b[i];
                }
                return m;
            }
            public double disp() { //считаем дисперсию, для этого
                double d = 0;
                double m = 0;  //еще раз считаем мат ожидание
                double m2 = 0;  //используем ту же формулу мат ожидания только берем квадраты чисел
                for(int i = 0; i<n; i++){
                    m2 += Math.pow(a[i], 2) * b[i];
                }
                for(int i = 0; i<n; i++) {
                    m += a[i] * b[i];
                }
                d = m2 - Math.pow(m, 2);  //вычитаем полученные величины
                return d;
            }
            public double StandDev() {  //считаем среднее квадратичное отклонение
                double d = 0;
                double s = 0;
                double m = 0;
                double m2 = 0;
                for(int i = 0; i<n; i++){
                    m2 += Math.pow(a[i], 2) * b[i];
                }
                for(int i = 0; i<n; i++) {
                    m += a[i] * b[i];
                }
                d = m2 - Math.pow(m, 2);  //для этого снова находим дисперсию а затем вычисляем из нее корень
                s = Math.sqrt(d);
                return s;
            }
            public void ValueSquar() {  //далее добавляем возможность проводить операции над случайными величинами
                for (int i = 0; i < n; i++) {
                    a[i] = Math.pow(a[i], 2);  //возведение всех величин в квадрат
                }
            }
            public void ValueMult(double x) {  //умножение всех величин на введенное число
                for (int i = 0; i < n; i++) {
                    a[i] = a[i] * x;
                }
            }
            public void ValuePlus(double x) {  //прибавление ко всем велечинам числа
                for (int i = 0; i < n; i++) {
                    a[i] = a[i] + x;
                }
            }
            public double Mediana() { //алгоритм поиска медианы
                double m = 0;
                if(n%2==1) {  //если количество случайных величин нечетное, то медиана это число по середине
                    m = a[n/2];
                }
                else {
                    m = (a[n / 2] + a[(n / 2) - 1]) / 2; //если колво четное, то это ср арифм между двумя средними числами
                }
                return m;
            }
            public int MostLikelyNum() {  //поиск наиболее вероятной величины
                double mx = b[0];
                int k = 0;
                for(int i = 0; i<n; i++) {
                    if(b[i]>b[0]) {
                        mx = b[i];  //ищем максимальную вероятность, затем возвращаем число с этой вероятностью
                        k = i;
                    }
                }
                return a[k];
            }
            public boolean IsNormal() { //проверяем нормальное ли распределение 
                double m = 0; //для этого еще раз ищем медиану
                if(n%2==1) {
                    m = a[n/2];
                }
                else {
                    m = (a[n / 2] + a[(n / 2) - 1]) / 2;
                }
                double mx = b[0];
                int k = 0;  //и число с наибольшей вероятностью
                for(int i = 0; i<n; i++) {
                    if(b[i]>b[0]) {
                        mx = b[i];
                        k = i;
                    }
                }
                return m==a[k];  //сравниваем их, если они равны - распределение нормальное и возвращается True, если нет - False
            }
            public double probability(int x) { //поиск вероятности введенного числа 
                int k = 0;
                double v = 0;
                for(int i = 0; i<n; i++) {
                    if(a[i]==x) {
                        k+=1;  //считаем сколько раз число встречается среди величин
                    }
                }
                v = k/n;  //затем делим это количество на общее число величин
                return v;
            }

        }
    }
    }
```
